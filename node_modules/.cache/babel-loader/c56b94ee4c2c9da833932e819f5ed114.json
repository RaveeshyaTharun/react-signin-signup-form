{"ast":null,"code":"export const streamChunk = function* (chunk, chunkSize) {\n  let len = chunk.byteLength;\n\n  if (!chunkSize || len < chunkSize) {\n    yield chunk;\n    return;\n  }\n\n  let pos = 0;\n  let end;\n\n  while (pos < len) {\n    end = pos + chunkSize;\n    yield chunk.slice(pos, end);\n    pos = end;\n  }\n};\nexport const readBytes = async function* (iterable, chunkSize, encode) {\n  for await (const chunk of iterable) {\n    yield* streamChunk(ArrayBuffer.isView(chunk) ? chunk : await encode(String(chunk)), chunkSize);\n  }\n};\nexport const trackStream = (stream, chunkSize, onProgress, onFinish, encode) => {\n  const iterator = readBytes(stream, chunkSize, encode);\n  let bytes = 0;\n  let done;\n\n  let _onFinish = e => {\n    if (!done) {\n      done = true;\n      onFinish && onFinish(e);\n    }\n  };\n\n  return new ReadableStream({\n    async pull(controller) {\n      try {\n        const {\n          done,\n          value\n        } = await iterator.next();\n\n        if (done) {\n          _onFinish();\n\n          controller.close();\n          return;\n        }\n\n        let len = value.byteLength;\n\n        if (onProgress) {\n          let loadedBytes = bytes += len;\n          onProgress(loadedBytes);\n        }\n\n        controller.enqueue(new Uint8Array(value));\n      } catch (err) {\n        _onFinish(err);\n\n        throw err;\n      }\n    },\n\n    cancel(reason) {\n      _onFinish(reason);\n\n      return iterator.return();\n    }\n\n  }, {\n    highWaterMark: 2\n  });\n};","map":{"version":3,"names":["streamChunk","chunk","chunkSize","len","byteLength","pos","end","slice","readBytes","iterable","encode","ArrayBuffer","isView","String","trackStream","stream","onProgress","onFinish","iterator","bytes","done","_onFinish","e","ReadableStream","pull","controller","value","next","close","loadedBytes","enqueue","Uint8Array","err","cancel","reason","return","highWaterMark"],"sources":["E:/Final Project/react-signin-signup-form/node_modules/axios/lib/helpers/trackStream.js"],"sourcesContent":["\nexport const streamChunk = function* (chunk, chunkSize) {\n  let len = chunk.byteLength;\n\n  if (!chunkSize || len < chunkSize) {\n    yield chunk;\n    return;\n  }\n\n  let pos = 0;\n  let end;\n\n  while (pos < len) {\n    end = pos + chunkSize;\n    yield chunk.slice(pos, end);\n    pos = end;\n  }\n}\n\nexport const readBytes = async function* (iterable, chunkSize, encode) {\n  for await (const chunk of iterable) {\n    yield* streamChunk(ArrayBuffer.isView(chunk) ? chunk : (await encode(String(chunk))), chunkSize);\n  }\n}\n\nexport const trackStream = (stream, chunkSize, onProgress, onFinish, encode) => {\n  const iterator = readBytes(stream, chunkSize, encode);\n\n  let bytes = 0;\n  let done;\n  let _onFinish = (e) => {\n    if (!done) {\n      done = true;\n      onFinish && onFinish(e);\n    }\n  }\n\n  return new ReadableStream({\n    async pull(controller) {\n      try {\n        const {done, value} = await iterator.next();\n\n        if (done) {\n         _onFinish();\n          controller.close();\n          return;\n        }\n\n        let len = value.byteLength;\n        if (onProgress) {\n          let loadedBytes = bytes += len;\n          onProgress(loadedBytes);\n        }\n        controller.enqueue(new Uint8Array(value));\n      } catch (err) {\n        _onFinish(err);\n        throw err;\n      }\n    },\n    cancel(reason) {\n      _onFinish(reason);\n      return iterator.return();\n    }\n  }, {\n    highWaterMark: 2\n  })\n}\n"],"mappings":"AACA,OAAO,MAAMA,WAAW,GAAG,WAAWC,KAAX,EAAkBC,SAAlB,EAA6B;EACtD,IAAIC,GAAG,GAAGF,KAAK,CAACG,UAAhB;;EAEA,IAAI,CAACF,SAAD,IAAcC,GAAG,GAAGD,SAAxB,EAAmC;IACjC,MAAMD,KAAN;IACA;EACD;;EAED,IAAII,GAAG,GAAG,CAAV;EACA,IAAIC,GAAJ;;EAEA,OAAOD,GAAG,GAAGF,GAAb,EAAkB;IAChBG,GAAG,GAAGD,GAAG,GAAGH,SAAZ;IACA,MAAMD,KAAK,CAACM,KAAN,CAAYF,GAAZ,EAAiBC,GAAjB,CAAN;IACAD,GAAG,GAAGC,GAAN;EACD;AACF,CAhBM;AAkBP,OAAO,MAAME,SAAS,GAAG,iBAAiBC,QAAjB,EAA2BP,SAA3B,EAAsCQ,MAAtC,EAA8C;EACrE,WAAW,MAAMT,KAAjB,IAA0BQ,QAA1B,EAAoC;IAClC,OAAOT,WAAW,CAACW,WAAW,CAACC,MAAZ,CAAmBX,KAAnB,IAA4BA,KAA5B,GAAqC,MAAMS,MAAM,CAACG,MAAM,CAACZ,KAAD,CAAP,CAAlD,EAAoEC,SAApE,CAAlB;EACD;AACF,CAJM;AAMP,OAAO,MAAMY,WAAW,GAAG,CAACC,MAAD,EAASb,SAAT,EAAoBc,UAApB,EAAgCC,QAAhC,EAA0CP,MAA1C,KAAqD;EAC9E,MAAMQ,QAAQ,GAAGV,SAAS,CAACO,MAAD,EAASb,SAAT,EAAoBQ,MAApB,CAA1B;EAEA,IAAIS,KAAK,GAAG,CAAZ;EACA,IAAIC,IAAJ;;EACA,IAAIC,SAAS,GAAIC,CAAD,IAAO;IACrB,IAAI,CAACF,IAAL,EAAW;MACTA,IAAI,GAAG,IAAP;MACAH,QAAQ,IAAIA,QAAQ,CAACK,CAAD,CAApB;IACD;EACF,CALD;;EAOA,OAAO,IAAIC,cAAJ,CAAmB;IACxB,MAAMC,IAAN,CAAWC,UAAX,EAAuB;MACrB,IAAI;QACF,MAAM;UAACL,IAAD;UAAOM;QAAP,IAAgB,MAAMR,QAAQ,CAACS,IAAT,EAA5B;;QAEA,IAAIP,IAAJ,EAAU;UACTC,SAAS;;UACRI,UAAU,CAACG,KAAX;UACA;QACD;;QAED,IAAIzB,GAAG,GAAGuB,KAAK,CAACtB,UAAhB;;QACA,IAAIY,UAAJ,EAAgB;UACd,IAAIa,WAAW,GAAGV,KAAK,IAAIhB,GAA3B;UACAa,UAAU,CAACa,WAAD,CAAV;QACD;;QACDJ,UAAU,CAACK,OAAX,CAAmB,IAAIC,UAAJ,CAAeL,KAAf,CAAnB;MACD,CAfD,CAeE,OAAOM,GAAP,EAAY;QACZX,SAAS,CAACW,GAAD,CAAT;;QACA,MAAMA,GAAN;MACD;IACF,CArBuB;;IAsBxBC,MAAM,CAACC,MAAD,EAAS;MACbb,SAAS,CAACa,MAAD,CAAT;;MACA,OAAOhB,QAAQ,CAACiB,MAAT,EAAP;IACD;;EAzBuB,CAAnB,EA0BJ;IACDC,aAAa,EAAE;EADd,CA1BI,CAAP;AA6BD,CAzCM"},"metadata":{},"sourceType":"module"}